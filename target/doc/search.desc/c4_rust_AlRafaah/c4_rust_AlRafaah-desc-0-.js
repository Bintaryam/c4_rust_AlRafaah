searchState.loadedDescShard("c4_rust_AlRafaah", 0, "Abstract Syntax Tree (AST) for the C4 compiler subset in …\nLexer for the C4 compiler subset in Rust. Takes a &amp;str and …\nBinary operators in C4.\nA block <code>{ ... }</code>: a sequence of statements.\nAn anonymous enum declaration: e.g., …\nExpressions in C4.\nA function definition: <code>int f(int a, char b) { ... }</code>\nA global variable declaration: e.g., <code>int x;</code> or <code>char *p;</code>\nArray indexing <code>array[index]</code>\nTop-level items: global variables, functions, or enum …\nA full C4 program: a list of top-level items.\nStatements in C4.\nTypes in C4: void, int, char, or pointer to.\nUnary operators, including prefix/postfix.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nName and type of a single declarator. (Comma‐separated …\nList of (name, optional initializer)\nCall instruction with target address\nRepresents a compiled chunk of instructions\nRaw instruction with optional operands\nInstruction with immediate value (e.g. IMM, LEA, ADJ)\nA single instruction can be an OpCode with optional …\nJump instructions with target address\nDefines the bytecode instruction set, along with helper …\nDebug helper to print all instructions\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdd a no-operand instruction\nAdd a call instruction\nAdd an instruction with an integer operand (e.g., IMM 42)\nAdd a jump instruction\nchar literal, with escape processing\nend-of-input marker\nidentifier\nThe lexer struct wraps the input string and a peekable …\nint literal (decimal, hex/octal can be added)\nstring literal, with escape processing\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new lexer instance.\nReturn the next token or a LexError.\nRecursive‐descent parser covering 100% of C4 grammar, …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInitialize parser and read first token.\nParse an entire program.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")